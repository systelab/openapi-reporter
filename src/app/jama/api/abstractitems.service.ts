/**
 * Jama REST API
 * This is the documentation for the Jama REST API.
 *
 * OpenAPI spec version: latest
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';

import { Observable } from 'rxjs';
import '../rxjs-operators';

import { AbstractItemDataWrapper } from '../model/abstractItemDataWrapper';
import { AbstractVersionedItemDataWrapper } from '../model/abstractVersionedItemDataWrapper';
import { ItemDataListWrapper } from '../model/itemDataListWrapper';
import { VersionDataListWrapper } from '../model/versionDataListWrapper';
import { VersionDataWrapper } from '../model/versionDataWrapper';
import { VersionedRelationshipDataListWrapper } from '../model/versionedRelationshipDataListWrapper';

import { BASE_PATH } from '../variables';
import { Configuration } from '../configuration';

@Injectable()
export class AbstractitemsService {

	protected basePath = 'https://jama.systelab.net/contour/rest/latest';
	public defaultHeaders = new HttpHeaders();
	public configuration = new Configuration();

	constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
		if (basePath) {
			this.basePath = basePath;
		}
		if (configuration) {
			this.configuration = configuration;
			this.basePath = basePath || configuration.basePath || this.basePath;
		}
	}

	/**
	 * @param consumes string[] mime-types
	 * @return true: consumes contains 'multipart/form-data', false: otherwise
	 */
	private canConsumeForm(consumes: string[]): boolean {
		const form = 'multipart/form-data';
		for (let consume of consumes) {
			if (form === consume) {
				return true;
			}
		}
		return false;
	}

	public isJsonMime(mime: string): boolean {
		const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
		return mime != null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
	}

	/**
	 * Search for items, test plans, test cycles, test runs, or attachments
	 *
	 * @param project
	 * @param itemType
	 * @param documentKey
	 * @param release
	 * @param createdDate Filter datetime fields after a single date or within a range of values. Provide one or two values in ISO8601 format (milliseconds or seconds) - \&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ\&quot; or \&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ssZ\&quot;
	 * @param modifiedDate Filter datetime fields after a single date or within a range of values. Provide one or two values in ISO8601 format (milliseconds or seconds) - \&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ\&quot; or \&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ssZ\&quot;
	 * @param lastActivityDate Filter datetime fields after a single date or within a range of values. Provide one or two values in ISO8601 format (milliseconds or seconds) - \&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ\&quot; or \&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ssZ\&quot;
	 * @param contains Filter on the text contents of the item. Strings taken literally. Multiple &#39;contains&#39; values will be bitwise ORed.
	 * @param sortBy Sort orders can be added with the name of the field by which to sort, followed by .asc or .desc (e.g. &#39;name.asc&#39; or &#39;modifiedDate.desc&#39;). If not set, this defaults to sorting by sequence.asc and then documentKey.asc
	 * @param startAt
	 * @param maxResults If not set, this defaults to 20. This cannot be larger than 50
	 * @param include Links to include as full objects in the linked map
	 */
	public getAbstractItems(project?: Array<number>, itemType?: Array<number>, documentKey?: Array<string>, release?: Array<number>, createdDate?: Array<string>, modifiedDate?: Array<string>, lastActivityDate?: Array<string>, contains?: Array<string>, sortBy?: Array<string>, startAt?: number, maxResults?: number, include?: Array<string>): Observable<ItemDataListWrapper> {

		let queryParameters = new HttpParams();
		if (project) {
			project.forEach((element) => {
				queryParameters = queryParameters.append('project', <any>element);
			})
		}
		if (itemType) {
			itemType.forEach((element) => {
				queryParameters = queryParameters.append('itemType', <any>element);
			})
		}
		if (documentKey) {
			documentKey.forEach((element) => {
				queryParameters = queryParameters.append('documentKey', <any>element);
			})
		}
		if (release) {
			release.forEach((element) => {
				queryParameters = queryParameters.append('release', <any>element);
			})
		}
		if (createdDate) {
			createdDate.forEach((element) => {
				queryParameters = queryParameters.append('createdDate', <any>element);
			})
		}
		if (modifiedDate) {
			modifiedDate.forEach((element) => {
				queryParameters = queryParameters.append('modifiedDate', <any>element);
			})
		}
		if (lastActivityDate) {
			lastActivityDate.forEach((element) => {
				queryParameters = queryParameters.append('lastActivityDate', <any>element);
			})
		}
		if (contains) {
			contains.forEach((element) => {
				queryParameters = queryParameters.append('contains', <any>element);
			})
		}
		if (sortBy) {
			sortBy.forEach((element) => {
				queryParameters = queryParameters.append('sortBy', <any>element);
			})
		}
		if (startAt !== undefined) {
			queryParameters = queryParameters.set('startAt', <any>startAt);
		}
		if (maxResults !== undefined) {
			queryParameters = queryParameters.set('maxResults', <any>maxResults);
		}
		if (include) {
			include.forEach((element) => {
				queryParameters = queryParameters.append('include', <any>element);
			})
		}

		let headers = this.defaultHeaders;

		// authentication (basic) required
		if (this.configuration.username || this.configuration.password) {
			headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
		}

		// authentication (oauth2) required
		if (this.configuration.accessToken) {
			let accessToken = typeof this.configuration.accessToken === 'function'
				? this.configuration.accessToken()
				: this.configuration.accessToken;
			headers = headers.set('Authorization', 'Bearer ' + accessToken);
		}

		return this.httpClient.get<any>(`${this.basePath}/abstractitems`, {
			params:          queryParameters,
			headers:         headers,
			withCredentials: this.configuration.withCredentials,
		});
	}

	/**
	 * Get any item, test plan, test cycle, test run, or attachment with the specified ID
	 *
	 * @param id
	 * @param include Links to include as full objects in the linked map
	 */
	public getItem(id: number, include?: Array<string>): Observable<AbstractItemDataWrapper> {
		if (id === null || id === undefined) {
			throw new Error('Required parameter id was null or undefined when calling getItem.');
		}

		let queryParameters = new HttpParams();
		if (include) {
			include.forEach((element) => {
				queryParameters = queryParameters.append('include', <any>element);
			})
		}

		let headers = this.defaultHeaders;

		// authentication (basic) required
		if (this.configuration.username || this.configuration.password) {
			headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
		}

		// authentication (oauth2) required
		if (this.configuration.accessToken) {
			let accessToken = typeof this.configuration.accessToken === 'function'
				? this.configuration.accessToken()
				: this.configuration.accessToken;
			headers = headers.set('Authorization', 'Bearer ' + accessToken);
		}

		return this.httpClient.get<any>(`${this.basePath}/abstractitems/${encodeURIComponent(String(id))}`, {
			params:          queryParameters,
			headers:         headers,
			withCredentials: this.configuration.withCredentials,
		});
	}

	/**
	 * Get the numbered version for the item with the specified ID
	 *
	 * @param versionNum
	 * @param id
	 * @param include Links to include as full objects in the linked map
	 */
	public getVersionOnItem(versionNum: number, id: number, include?: Array<string>): Observable<VersionDataWrapper> {
		if (versionNum === null || versionNum === undefined) {
			throw new Error('Required parameter versionNum was null or undefined when calling getVersionOnItem.');
		}
		if (id === null || id === undefined) {
			throw new Error('Required parameter id was null or undefined when calling getVersionOnItem.');
		}

		let queryParameters = new HttpParams();
		if (include) {
			include.forEach((element) => {
				queryParameters = queryParameters.append('include', <any>element);
			})
		}

		let headers = this.defaultHeaders;

		// authentication (basic) required
		if (this.configuration.username || this.configuration.password) {
			headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
		}

		// authentication (oauth2) required
		if (this.configuration.accessToken) {
			let accessToken = typeof this.configuration.accessToken === 'function'
				? this.configuration.accessToken()
				: this.configuration.accessToken;
			headers = headers.set('Authorization', 'Bearer ' + accessToken);
		}

		return this.httpClient.get<any>(`${this.basePath}/abstractitems/${encodeURIComponent(String(id))}/versions/${encodeURIComponent(String(versionNum))}`, {
			params:          queryParameters,
			headers:         headers,
			withCredentials: this.configuration.withCredentials,
		});
	}

	/**
	 * Get the  snapshot of the item at the specified version
	 *
	 * @param versionNum
	 * @param id
	 * @param include Links to include as full objects in the linked map
	 */
	public getVersionedItem(versionNum: number, id: number, include?: Array<string>): Observable<AbstractVersionedItemDataWrapper> {
		if (versionNum === null || versionNum === undefined) {
			throw new Error('Required parameter versionNum was null or undefined when calling getVersionedItem.');
		}
		if (id === null || id === undefined) {
			throw new Error('Required parameter id was null or undefined when calling getVersionedItem.');
		}

		let queryParameters = new HttpParams();
		if (include) {
			include.forEach((element) => {
				queryParameters = queryParameters.append('include', <any>element);
			})
		}

		let headers = this.defaultHeaders;

		// authentication (basic) required
		if (this.configuration.username || this.configuration.password) {
			headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
		}

		// authentication (oauth2) required
		if (this.configuration.accessToken) {
			let accessToken = typeof this.configuration.accessToken === 'function'
				? this.configuration.accessToken()
				: this.configuration.accessToken;
			headers = headers.set('Authorization', 'Bearer ' + accessToken);
		}

		return this.httpClient.get<any>(`${this.basePath}/abstractitems/${encodeURIComponent(String(id))}/versions/${encodeURIComponent(String(versionNum))}/versioneditem`, {
			params:          queryParameters,
			headers:         headers,
			withCredentials: this.configuration.withCredentials,
		});
	}

	/**
	 * Get all versioned relationships that were associated to the item at the specified time
	 *
	 * @param id
	 * @param timestamp Get relationships for the specified item at this date and time. Requires ISO8601 formatting (milliseconds or seconds) - \&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ\&quot; or \&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ssZ\&quot;
	 * @param startAt
	 * @param maxResults If not set, this defaults to 20. This cannot be larger than 50
	 * @param include Links to include as full objects in the linked map
	 */
	public getVersionedRelationships(id: number, timestamp: string, startAt?: number, maxResults?: number, include?: Array<string>): Observable<VersionedRelationshipDataListWrapper> {
		if (id === null || id === undefined) {
			throw new Error('Required parameter id was null or undefined when calling getVersionedRelationships.');
		}
		if (timestamp === null || timestamp === undefined) {
			throw new Error('Required parameter timestamp was null or undefined when calling getVersionedRelationships.');
		}

		let queryParameters = new HttpParams();
		if (timestamp !== undefined) {
			queryParameters = queryParameters.set('timestamp', <any>timestamp);
		}
		if (startAt !== undefined) {
			queryParameters = queryParameters.set('startAt', <any>startAt);
		}
		if (maxResults !== undefined) {
			queryParameters = queryParameters.set('maxResults', <any>maxResults);
		}
		if (include) {
			include.forEach((element) => {
				queryParameters = queryParameters.append('include', <any>element);
			})
		}

		let headers = this.defaultHeaders;

		// authentication (basic) required
		if (this.configuration.username || this.configuration.password) {
			headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
		}

		// authentication (oauth2) required
		if (this.configuration.accessToken) {
			let accessToken = typeof this.configuration.accessToken === 'function'
				? this.configuration.accessToken()
				: this.configuration.accessToken;
			headers = headers.set('Authorization', 'Bearer ' + accessToken);
		}

		return this.httpClient.get<any>(`${this.basePath}/abstractitems/${encodeURIComponent(String(id))}/versionedrelationships`, {
			params:          queryParameters,
			headers:         headers,
			withCredentials: this.configuration.withCredentials,
		});
	}

	/**
	 * Get all versions for the item with the specified ID
	 *
	 * @param id
	 * @param startAt
	 * @param maxResults If not set, this defaults to 20. This cannot be larger than 50
	 * @param include Links to include as full objects in the linked map
	 */
	public getVersionsOnItem(id: number, startAt?: number, maxResults?: number, include?: Array<string>): Observable<VersionDataListWrapper> {
		if (id === null || id === undefined) {
			throw new Error('Required parameter id was null or undefined when calling getVersionsOnItem.');
		}

		let queryParameters = new HttpParams();
		if (startAt !== undefined) {
			queryParameters = queryParameters.set('startAt', <any>startAt);
		}
		if (maxResults !== undefined) {
			queryParameters = queryParameters.set('maxResults', <any>maxResults);
		}
		if (include) {
			include.forEach((element) => {
				queryParameters = queryParameters.append('include', <any>element);
			})
		}

		let headers = this.defaultHeaders;

		// authentication (basic) required
		if (this.configuration.username || this.configuration.password) {
			headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
		}

		// authentication (oauth2) required
		if (this.configuration.accessToken) {
			let accessToken = typeof this.configuration.accessToken === 'function'
				? this.configuration.accessToken()
				: this.configuration.accessToken;
			headers = headers.set('Authorization', 'Bearer ' + accessToken);
		}

		return this.httpClient.get<any>(`${this.basePath}/abstractitems/${encodeURIComponent(String(id))}/versions`, {
			params:          queryParameters,
			headers:         headers,
			withCredentials: this.configuration.withCredentials,
		});
	}

}
